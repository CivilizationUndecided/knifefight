@namespace Facepunch
@attribute [StyleSheet]

<root class="with-background with-rounding">
    @if (Renderer.IsValid())
    {
        <div>
            <div class="minimap" style="background-image: url( @Renderer.CurrentMinimapPath );" />
            <div class="overlay" style="background-image: url( @Renderer.CurrentMinimapPath );" />

            <div class="markers">
                @foreach (var player in GetPlayers())
                {
                    if (player.Tags.Has("invis"))
                        continue;

                    if ( player.HealthComponent.State == LifeState.Dead )
                    {
                        <div class="marker dead" style="@WorldToMap(player.Transform.Position)" />
                    }
                    else
                    {
                        <div class="marker @GetPlayerClass(player)" style="@WorldToMap(player.Transform.Position) @RotationToMap(player.EyeAngles) @GetPlayerColor(player)" />
                    }
                }
                @foreach (var element in Game.ActiveScene.GetAllComponents<IMinimapElement>())
                {
                    if ( !element.IsValid() || !element.IsVisible(GameUtils.Viewer) )
                        continue;

                    if ( element is IMinimapVolume volume )
                    {
                        <div class="volume" style="@GetBox(volume) background-color: @volume.Color.Rgba;" />
                    }
                    if (element is IMinimapIcon icon && icon.IconType != MinimapIconType.None)
                    {
                        <div class="marker @icon.IconType.GetClass()" style="@WorldToMap(icon.WorldPosition) @((icon as ICustomMinimapIcon)?.CustomStyle ?? "")" />
                    }
                    if (element is IMinimapLabel label)
                    {
                        <div class="label" style="@WorldToMap(label.WorldPosition)">
                            @label.Label
                        </div>
                    }
                }
                @if ( SpectateSystem.Instance?.IsFreecam ?? false )
                {
                    var spectateController = SpectateSystem.Instance.FreecamController;
                    <div class="marker" style="@WorldToMap(spectateController.Transform.Position) @RotationToMap(spectateController.Transform.Rotation.Angles())" />
                }
            </div>
        </div>
    }
</root>

@code
{
    public MinimapRenderer Renderer => Game.ActiveScene.GetAllComponents<MinimapRenderer>().FirstOrDefault();

    IEnumerable<PlayerController> GetPlayers()
    {
        if ( GameUtils.LocalPlayer?.IsSpectating ?? false || GameUtils.Viewer is null )
        {
            return GameUtils.AllPlayers;
        }

        return GameUtils.GetPlayers(GameUtils.Viewer.TeamComponent.Team);
    }

    // player
    string GetPlayerColor( PlayerController player )
    {
        if ((player as IPawn).IsPossessed)
        {
            return "background-image-tint: rgba( 0, 255, 255, 1 )";
        }

        return $"background-image-tint: {player.TeamComponent.Team.GetColor().Hex}";
    }

    string GetPlayerClass( PlayerController player )
    {
        return (player as IPawn).IsPossessed ? "viewer" : "";
    }

    // generic
    string WorldToMap( Vector3 worldPosition )
    {
        var position = Renderer.RemapCoords(worldPosition);
        return $"left: {Length.Fraction(position.x)}; top: {Length.Fraction(position.y)};";
    }

    string GetBox( IMinimapVolume volume )
    {
        var position = Renderer.RemapCoords(volume.WorldPosition + (volume.Size / 2));
        var scaledSize = (Vector2)(volume.Size / 2) * (Renderer.ExportResolution / Renderer.Size) / 2;
        return $"left: {Length.Fraction(position.x)}; top: {Length.Fraction(position.y)}; width:{scaledSize.y}px; height:{scaledSize.x}px;";
    }

    string RotationToMap( Angles rot )
	{
		return $"transform: translateX(-50%) translateY(-50%) rotate({-rot.yaw}deg);";
	}

    protected override int BuildHash()
    {
        return System.HashCode.Combine( Time.Now );
    }
}